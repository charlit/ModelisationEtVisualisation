<!DOCTYPE html>
<html>
<head>
    <title>01.01 - Basic scene</title>
    <script src="./libs/jquery-1.9.0.js"></script>
   
    <script src="./libs/three.js"></script>
     <script src="./libs/OrbitControls.js"></script>
    <script src="./libs/perlin.js"></script>
    <script src="./libs/physi.js"></script>

    <style>
        body {
            /* set margin to 0 and overflow to hidden, to go fullscreen */
            margin: 0;
            overflow: hidden;
        }
    </style>
    <script type="text/javascript">
    	Physijs.scripts.worker = './libs/physijs_worker.js';
    	Physijs.scripts.ammo = 'ammo.js';

    	var scene = new Physijs.Scene;
    	scene.setGravity(new THREE.Vector3(0,-50,0));

    </script>
</head>
<script>

    // global variables
    var renderer;
    var scene;
    var camera;
    var cameraControl;
    var projector;
    var collidableMeshList = new Array();




    /**
     * Initializes the scene, camera and objects. Called when the window is
     * loaded by using window.onload (see below)
     */
     function init() {

        // create a scene, that will hold all our elements such as objects, cameras and lights.
       // scene = new THREE.Scene();
         scene = new Physijs.Scene;
        projector = new THREE.Projector();
        // create a camera, which defines where we're looking at.
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);        
        // position and point the camera to the center of the scene
        camera.position.x = 10;
        camera.position.y = 6;
        camera.position.z = 13;
        camera.lookAt(scene.position);
        cameraControl = new THREE.OrbitControls(camera);
      

        // create a render, sets the background color and the size
        renderer = new THREE.WebGLRenderer();
        renderer.setClearColor(0x000000, 1.0);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMapEnabled = true;

        create3DTerrain(80);
		addboule();
function addboule()
{
		for(i=0; i<10; i++)
		{
        var sphere_geometry = new THREE.SphereGeometry( 1.5, 32, 32 );
        var shape, material = new THREE.MeshLambertMaterial({ opacity: 1, transparent: true });
        shape = new Physijs.SphereMesh(
						sphere_geometry,
						material,
						undefined,
						{ restitution: Math.random() * 1.5 }
					);

			shape.position.set(
				0,
				Math.random()*40,
				0
			);
		scene.add(shape);
		}
}

      

        var directionalLight2 = new THREE.DirectionalLight(0xe8bd0, 1.5);
        directionalLight2.position.set(2950,2625,-160);
        scene.add(directionalLight2);

        var ambientLight = new THREE.DirectionalLight(0xc3eadd, 0.75);
        directionalLight2.position.set(-1,-0.5,-1);
        scene.add(ambientLight);

        // add the output of the renderer to the html element
        document.body.appendChild(renderer.domElement);

        // call the render function, after the first render, interval is determined
        // by requestAnimationFrame
        render();
    }

    /**
     * Called when the scene needs to be rendered. Delegates to requestAnimationFrame
     * for future renders
     */
     function render() {      
   		scene.simulate();
     	cameraControl.update();
        // render using requestAnimationFrame
        renderer.render(scene, camera);
        requestAnimationFrame(render);

    }


    /**
     * Function handles the resize event. This make sure the camera and the renderer
     * are updated at the correct moment.
     */
     function handleResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function create3DTerrain(height) {
    	var plane = new THREE.PlaneGeometry(120,120,100,100);
    	var d = new Date();
    	var n = d.getTime();
    	var pn = new Perlin(n);
    	for(var i = 0; i < plane.vertices.length; i++)
    	{

			
    	
    		var vertex = plane.vertices[i];

    		var value = Math.abs(pn.noise(vertex.x / 10, vertex.y / 10, 0));

    		vertex.z = value * 10;
    	}
    

	    plane.computeVertexNormals(true);
	    plane.computeFaceNormals(true);

	    /*var mat = new THREE.MeshPhongMaterial();
	    mat.map = THREE.ImageUtils.loadTexture("./textures/ground/grasslight-big.jpg");


	    mat.vertexColors = THREE.FaceColors;
	    mat.shading = THREE.NoShading;

	    var groundMesh = new THREE.Mesh(plane, mat);
	  	groundMesh.rotation.x =  -(Math.PI / 2);*/



		ground_material = Physijs.createMaterial(
        	new THREE.MeshPhongMaterial({map: THREE.ImageUtils.loadTexture('./textures/ground/grasslight-big.jpg')}),
        	.9,
        	.6
        );

		ground = new Physijs.HeightfieldMesh(
			plane,
			ground_material,
			0, // mass
			100, 
			100
		);

		ground.rotation.x = Math.PI / -2;
		ground.receiveShadow = true;
	    scene.add(ground);
  	}


    // calls the init function when the window is done loading.
    window.onload = init;
    // calls the handleResize function when the window is resized
    window.addEventListener('resize', handleResize, false);
</script>
<body>
</body>
</html>